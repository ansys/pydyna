ansys.dyna.core.lib.deck_plotter
================================

.. py:module:: ansys.dyna.core.lib.deck_plotter

.. autoapi-nested-parse::

   Module for plotting decks.

   ..
       !! processed by numpydoc !!


Functions
---------

.. autoapisummary::

   ansys.dyna.core.lib.deck_plotter.get_nid_to_index_mapping
   ansys.dyna.core.lib.deck_plotter.merge_keywords
   ansys.dyna.core.lib.deck_plotter.process_nodes
   ansys.dyna.core.lib.deck_plotter.shell_facet_array
   ansys.dyna.core.lib.deck_plotter.solid_array
   ansys.dyna.core.lib.deck_plotter.line_array
   ansys.dyna.core.lib.deck_plotter.map_facet_nid_to_index
   ansys.dyna.core.lib.deck_plotter.extract_shell_facets
   ansys.dyna.core.lib.deck_plotter.extract_lines
   ansys.dyna.core.lib.deck_plotter.extract_solids
   ansys.dyna.core.lib.deck_plotter.get_pyvista
   ansys.dyna.core.lib.deck_plotter.is_jupyter_environment
   ansys.dyna.core.lib.deck_plotter.get_polydata
   ansys.dyna.core.lib.deck_plotter.plot_deck


Module Contents
---------------

.. py:function:: get_nid_to_index_mapping(nodes) -> numpy.ndarray

   
   Create array-based node ID to index mapping.

   Returns an array where mapping[nid] = index.
   This is much faster than dict-based lookup (5000x+ speedup).















   ..
       !! processed by numpydoc !!

.. py:function:: merge_keywords(deck: ansys.dyna.core.Deck) -> Tuple[pandas.DataFrame, Dict]

   
   Merge mesh keywords.

   Given a deck, merges specific keywords (NODE, ELEMENT_SHELL, ELEMENT_BEAM, ELEMENT_SOLID)
   and returns tham as data frames.















   ..
       !! processed by numpydoc !!

.. py:function:: process_nodes(nodes_df)

   
   Process nodes DataFrame to extract XYZ coordinates as a numpy array.
















   ..
       !! processed by numpydoc !!

.. py:function:: shell_facet_array(facets: pandas.DataFrame) -> numpy.array

   
   Get the shell facet array from the DataFrame.

   Facets are a pandas frame that is a sequence of integers
   or NAs with max length of 8.
   valid rows contain 3,4,6, or 8 items consecutive from the
   left.  we don't plot quadratic edges so 6/8 collapse to 3/4
   invalid rows are ignored, meaning they return an empty array
   return an array of length 4 or 5 using the pyvista spec
   for facets which includes a length prefix
   [1,2,3]=>[3,1,2,3]
   [1,2,3,0]=>[3,1,2,3]
   [1,2,3,NA]=>[3,1,2,3]















   ..
       !! processed by numpydoc !!

.. py:function:: solid_array(solids: pandas.DataFrame)

   
   Get the solid array from the DataFrame.

   Solids are a pandas frame that is a sequence of integers
   or NAs with max length of 28.
   valid rows contain 3, 4, 6, or 8 items consecutive from the
   left.  We don't plot quadratic edges so 6/8 collapse to 3/4
   invalid rows are ignored, meaning they return an empty array
   return an array of length 4 or 5 using the pyvista spec
   for facets which includes a length prefix
   [1,2,3]=>[3,1,2,3]
   [1,2,3,0]=>[3,1,2,3]
   [1,2,3,NA]=>[3,1,2,3]















   ..
       !! processed by numpydoc !!

.. py:function:: line_array(lines: pandas.DataFrame) -> numpy.array

   
   Convert DataFrame to lines array.

   `lines` is a pandas frame that is a sequence of integers
   or NAs with max length of 2.
   valid rows contain 2 items consecutive from the
   left.
   invalid rows are ignored, meaning they return an empty array
   return an array of length 3 using the pyvista spec
   for facets which includes a length prefix
   [1,2,]=>[2,1,2]
   [1,2,3,0]=>[]
   [1,2,3,NA]=>[]















   ..
       !! processed by numpydoc !!

.. py:function:: map_facet_nid_to_index(flat_facets: numpy.array, mapping: numpy.ndarray) -> numpy.array

   
   Convert node IDs to indices using array-based mapping.

   Given a flat list of facets or lines, use the mapping array to convert
   node IDs to Python indices for PyVista visualization.

   The mapping is a numpy array where mapping[nid] = index.















   ..
       !! processed by numpydoc !!

.. py:function:: extract_shell_facets(shells: pandas.DataFrame, mapping: numpy.ndarray)

   
   Extract shell faces from DataFrame - returns triangles and quads separately.

   Shells table comes in with the form
   |  eid  | nid1 | nid2 | nid3 | nid4
   |  1    | 10   | 11   | 12   |
   |  20   | 21   | 22   | 23   | 24

   Returns triangles and quads in separate arrays (already prefixed with count):
   - Triangles: [3, n1, n2, n3, 3, n1, n2, n3, ...]
   - Quads: [4, n1, n2, n3, n4, 4, n1, n2, n3, n4, ...]

   Elements with fewer than 3 valid nodes are skipped.




   :Returns:

       :class:`python:tuple`
           (triangles, tri_eids, tri_pids, quads, quad_eids, quad_pids)











   ..
       !! processed by numpydoc !!

.. py:function:: extract_lines(beams: pandas.DataFrame, mapping: numpy.ndarray) -> numpy.ndarray

   
   Extract lines from DataFrame.

   Beams table comes in with the form with extra information not supported,
   |  eid  | nid1 | nid2
   |  1    | 10   | 11
   |  20   | 21   | 22

     we only care about nid 1 and 2

   but the array needed for pyvista polydata is the same as in extract facets
   of the form where each element is prefixed by the length of the element node list
   [2,10,11,2,21,22]

   Take individual rows, extract the appropriate nid's and output a flat list of
   facets for pyvista















   ..
       !! processed by numpydoc !!

.. py:function:: extract_solids(solids: pandas.DataFrame, mapping: numpy.ndarray)

   
   Extract solid elements from DataFrame (optimized vectorized version).
















   ..
       !! processed by numpydoc !!

.. py:function:: get_pyvista()

   
   Method to import pyvista, raising an exception if not installed.
















   ..
       !! processed by numpydoc !!

.. py:function:: is_jupyter_environment()

   
   Check if code is running in a Jupyter notebook environment.





   :Returns:

       :ref:`bool <python:bltin-boolean-values>`
           True if running in Jupyter notebook/lab, False otherwise.











   ..
       !! processed by numpydoc !!

.. py:function:: get_polydata(deck: ansys.dyna.core.Deck, cwd=None, extract_surface=True)

   
   Create the PolyData Object for plotting from a given deck with nodes and elements.


   :Parameters:

       **deck** : :obj:`Deck`
           The deck to plot

       **cwd** : :class:`python:str`, :obj:`optional`
           Current working directory for expanding includes

       **extract_surface** : :ref:`bool <python:bltin-boolean-values>`, default=True
           If True, extract only the exterior surface for solid elements.
           This dramatically improves performance for large solid meshes with no visual difference,
           since only the surface is visible anyway. Set to False to include all cells.



   :Returns:

       :obj:`pyvista.UnstructuredGrid`
           UnstructuredGrid containing the mesh for visualization











   ..
       !! processed by numpydoc !!

.. py:function:: plot_deck(deck, **args)

   
   Plot the deck with automatic Jupyter notebook support.


   :Parameters:

       **deck** : :obj:`Deck`
           The deck to plot

       **cwd** : :class:`python:str`, :obj:`optional`
           Current working directory for expanding includes

       **jupyter_backend** : :class:`python:str`, :obj:`optional`
           Jupyter backend to use. Options are 'static', 'server', 'trame', or None.
           If not specified, automatically detects Jupyter environment and uses 'static'.
           Set to None to disable Jupyter mode explicitly.

       **color** : :class:`python:str`, :obj:`optional`
           Color of the mesh

       **scalars** : :class:`python:str`, :obj:`optional`
           Scalars to color by (e.g., 'part_ids', 'element_ids')

       **\*\*args**
           Additional keyword arguments passed to pyvista.plot()



   :Returns:

       :obj:`pyvista` :obj:`plot` or :obj:`camera` :obj:`position`
           Depends on the plotting backend used











   ..
       !! processed by numpydoc !!

