# Code Generation and Auto-Generated Keywords

Many keyword classes in `src/ansys/dyna/core/keywords/keyword_classes/auto/` are auto-generated by Jinja templates. Avoid modifying these files directly.

## Recent Progress: Dataclass Migration (December 2025)

**Objective**: Migrate codegen pipeline from dict-based to strongly-typed dataclass architecture for improved type safety, IDE support, and maintainability.


**Future Improvements**:
- Update all handler method signatures: `kwd_data: typing.Any` → `kwd_data: KeywordData`
- Remove Union types once all card/field sources use dataclasses exclusively
- Enable strict type checking throughout

See sections below for architectural details and migration patterns.

## Purpose

The purpose of the codegen system is to generate Python classes for LS-DYNA keywords. These keywords are described in details in the LS-DYNA manual.

## Validation Workflow

After updating the codegen system, use the validation script to ensure all checks pass:

```bash
# Quick validation (fast iteration during development)
bash codegen/validate.sh --quick

# Full validation (before committing/pushing)
bash codegen/validate.sh

# Custom validation (skip specific steps)
bash codegen/validate.sh --skip-tests       # Skip unit tests
bash codegen/validate.sh --skip-precommit   # Skip pre-commit hooks
bash codegen/validate.sh --skip-deadcode    # Skip dead code detection

# For debugging
bash codegen/validate.sh --verbose
```

**What the validation script does:**
1. Cleans and regenerates all keyword classes (`generate.py -c && generate.py`)
2. Checks for unintended changes via git diff (both auto/ and doc/)
3. Runs pre-commit hooks (unless `--skip-precommit`)
4. Detects dead code with coverage analysis (unless `--skip-deadcode`)
5. Runs codegen unit tests with pytest -m codegen (unless `--skip-tests`)

**Bash aliases** (see `codegen/README.md` for full list):
```bash
alias codegen-quick='bash codegen/validate.sh --quick'
alias codegen-validate='bash codegen/validate.sh'
alias codegen-check='bash codegen/validate.sh --skip-tests --skip-deadcode'
```

**CI Integration**: The CI uses the same validation script to ensure local and CI validation are identical.

## Codegen System: High-Level Design

The codegen system is responsible for generating Python classes and import machinery for LS-DYNA keywords. Its architecture consists of:

- **Specification Loading**: Reads keyword/card/field definitions from JSON manifest files (`kwd.json`, `manifest.json`, `additional-cards.json`).
- **Handler Pipeline**: Applies a series of handlers to process and transform the loaded specifications. Each handler encapsulates a specific transformation or enrichment step.
- **Template Rendering**: Uses Jinja templates to generate Python code for keyword classes, importers, and type mappings. Context for templates is built from processed specifications.
- **Output Management**: Writes generated files to the appropriate locations, typically under `src/ansys/dyna/core/keywords/keyword_classes/auto/`.

Note: kwd.json is extremely large, so the agent should never attempt to read it in its entirety

### Typical Flow

1. **Run `generate.py`**: Entry point for code generation. CLI options allow for cleaning (`-C`) and generation.
2. **Load Specs**: Manifest and keyword definitions are loaded and validated.
3. **Apply Handlers**: Each handler processes the data, adding relationships, defaults, or other logic.
4. **Render Templates**: Jinja templates are rendered using the processed context.
5. **Write Output**: Generated files are written to disk.

### Refactoring

Due to the complexity of the codegen, for any non-trivial refactoring, verify the codegen between independent
steps. Otherwise, after making many changes, it can be difficult to isolate and fix issues caused by
early steps.

### Extending or Customizing

- For changes affecting all keywords, update the codegen templates or handler logic.
- For keyword-specific customizations, create manual subclasses as described below.
- To test the generation of a specific keyword, use codegen.py -k SECTION_SHELL (for example).

See `codegen/todo.md` for architectural improvement recommendations.

## Handler System Architecture

### Handler Execution Order

Handlers transform keyword metadata during code generation. **Order matters** because handlers often depend on the output of previous handlers.

**Critical Ordering Principle**: Handlers are registered and executed in a specific order defined in `registry.py`. While the refactored system supports declaring dependencies via the `@handler` decorator, the current implementation uses **explicit registration order** to maintain backward compatibility and ensure reference semantics work correctly.

**Why Not Topological Sort?** The handler system includes infrastructure for dependency-based ordering (topological sort), but uses explicit registration order because handlers that group cards (`card-set`, `table-card-group`) rely on **reference semantics** - they append references to card dictionaries, not copies. Later handlers modify these same objects in-place. A pure dependency-based approach could reorder handlers in ways that break this pattern.

**Note**: Typed dataclasses (`KeywordData`, `Card`, `Field`) are available in `data_model/keyword_data.py` for improved type safety, with backward-compatible `to_dict()`/`from_dict()` methods for gradual migration.

### Handler Pipeline: Full Dataclass Migration
In progress

**Key Benefits**:
- Full IDE autocomplete and type checking
- Runtime validation with beartype
- Cleaner code with attribute access instead of dict subscripting
- Backward compatibility maintained during transition

### Type Hints and Metadata Classes

The codegen system uses typed metadata classes throughout the pipeline:

**Metadata Classes** (`data_model/metadata.py`):
- `TableCardMetadata` - for card["table"] (table cards)
- `VariableCardMetadata` - for card["variable"] (series cards)
- `ExternalCardMetadata` - for card["external"] (external implementations)
- `OptionGroup` - for kwd_data.options items
- `CardSet`, `CardSetsContainer` - for kwd_data.card_sets
- `LinkData` - for kwd_data.links items
- `MixinImport` - for kwd_data.mixin_imports items
- `DataclassDefinition`, `DataclassField` - for kwd_data.dataclasses items

**Core Data Structures** (`data_model/keyword_data.py`):
- `KeywordData` - Top-level keyword specification with typed attributes
- `Card` - Individual card with fields, metadata (duplicate, variable, external, etc.)
- `Field` - Field definition with type, description, default, etc.
- All include dict-like access (`__getitem__`, `__setitem__`) for backward compatibility

**Handler Settings** (in individual handler files):
- Each handler defines its own settings dataclass (e.g., `TableCardSettings` in `handlers/table_card.py`)
- Settings validated at parse time using `_parse_settings()` class method
- Type-safe configuration instead of raw dicts

**Migration Status**:
- Handler signatures still use `kwd_data: typing.Any` (future improvement)

### Dict-Like Access Pattern for Backward Compatibility

To enable gradual migration from dicts to dataclasses, `Card` and `Field` implement dict-like access:

```python
@dataclass
class Card:
    index: int = -1
    fields: List[Field] = field(default_factory=list)
    # ... other attributes ...

    def __getitem__(self, key: str) -> Any:
        """Dict-like access: card["index"] → card.index"""
        return getattr(self, key)

    def __setitem__(self, key: str, value: Any) -> None:
        """Dict-like assignment: card["index"] = 5 → card.index = 5"""
        setattr(self, key, value)

    def __contains__(self, key: str) -> bool:
        """Dict-like membership: "index" in card → hasattr(card, "index")"""
        return hasattr(self, key)

    def get(self, key: str, default: Any = None) -> Any:
        """Dict-like get: card.get("index", -1) → getattr(card, "index", -1)"""
        return getattr(self, key, default)
```

**Why This Approach?**
- Existing code using `card["index"]` continues to work
- New code can use `card.index` for IDE autocomplete
- Handlers can dynamically add metadata: `card["table"] = TableCardMetadata(...)`
- Type hints can use `Union[Card, Dict]` during transition, then migrate to `Card` only

**Trade-offs**:
- Dynamic attribute assignment bypasses type checking for new attributes
- Less explicit than pure dict or pure dataclass approach
- Temporary pattern - can be removed after full migration complete

### Migration Learnings and Best Practices

**Validation Strategy**:
- Run full codegen (`python codegen/generate.py`) after each incremental change
- Expected output: "Generated 3173 classes, skipped 15"
- Beartype provides detailed error messages for type violations - follow them iteratively

**Common Pitfalls**:
1. **Missing index field**: Cards loaded from kwd.json don't have `index` initially (added by generator)
   - Solution: `Card.from_dict()` uses `data.get("index", -1)` with default
2. **None sub_cards**: Some cards have `sub_cards: None` instead of empty list
   - Solution: Add None checks before iteration: `if card["sub_cards"]:`
3. **Field subscripting**: Fields need dict-like access just like Cards
   - Solution: Add `__getitem__`/`__setitem__` to Field dataclass too
4. **Union types during transition**: Type hints need `Union[Card, Dict]` until all sources converted
   - Solution: Update type hints progressively, validate with beartype
5. **Escaped docstrings**: Don't escape triple quotes in f-strings
   - Solution: Use raw strings `"""Docstring"""` not `\"\"\"Docstring\"\"\"`
6. **Missing optional attributes**: When migrating dicts to dataclasses, ensure ALL dict keys represented as dataclass attributes
   - Solution: Review source dicts (e.g., `additional-cards.json`) for all possible keys, add as optional attributes with defaults
   - Example: Field dataclass needs `on` and `off` for flag fields (default `"&"` for MPP2 flags)

**Incremental Migration Pattern**:
1. Add typed dataclass with `from_dict()` classmethod
2. Add dict-like access methods (`__getitem__`, `__setitem__`, etc.)
3. Update type hints to `Union[TypedClass, Dict]`
4. Run codegen and fix beartype errors iteratively
5. Once stable, tighten type hints to remove `Dict` from Union

**Known Issues**:
- CONSTRAINED.BEAM_IN_SOLID has manifest data issue (shared-field with 0 occurrences)
  - Handled gracefully with warning instead of assertion failure

**Standard Handler Order** (as of Dec 2025):
1. `reorder-card` - Reorders cards; must run first since other handlers use positional indices
2. `table-card` - Transforms cards into repeatable tables
3. `override-field` - Modifies field properties
4. `replace-card` - Replaces entire cards with different definitions
5. `insert-card` - Inserts new cards at specified positions
6. `series-card` - Transforms cards into variable-length series
7. `add-option` - Adds keyword options
8. `card-set` - Groups cards into reusable sets (uses references, not copies!)
9. `conditional-card` - Adds conditional logic to cards (modifies cards in-place)
10. `rename-property` - Renames property accessors
11. `skip-card` - Marks cards to be skipped
12. `table-card-group` - Groups multiple cards into repeating units
13. `external-card-implementation` - Links to externally defined cards
14. `shared-field` - Creates shared field definitions
15. `override-subkeyword` - Overrides subkeyword behavior

### Reference Semantics vs. Deep Copies

**CRITICAL**: Most handlers that group or copy cards (e.g., `card-set`, `table-card-group`) use **reference semantics** - they append the actual card dictionaries to their collections, NOT deep copies.

**Why?** Later handlers modify cards in-place. For example:
- `card-set` (handler #8) creates a card set by appending references to `source_cards`
- `conditional-card` (handler #9) later sets the `func` property on those same card objects
- Because they're the same objects, the changes appear in both places

**If you use `copy.deepcopy()`**: Changes made by later handlers won't appear in the card-set, breaking generation.

### Index Handling After Reordering

**The Index System**:
- Each card has an `index` property indicating its position
- `reorder-card` reorders the `kwd_data["cards"]` list but does NOT update card indices
- Subsequent handlers use list positions (e.g., `kwd_data["cards"][3]`) not the card's `index` property
- When `card-set` copies cards, it stores the original index in `source_index` and assigns new sequential indices

**Example** (SECTION_SHELL):
```json
// Original cards: [card0, card1, card2, card3, card4, card5]
// Reorder: [0, 1, 4, 2, 3, 5]
// After reorder: [card0, card1, card4, card2, card3, card5]
//                 pos0   pos1   pos2   pos3   pos4   pos5

// conditional-card with index:3 operates on position 3 (which is original card2)
// card-set with source-indices:[0,1,2,3,4,5] copies from positions 0-5
```

## When Auto-Generated Files Change

If you need to extend or customize a keyword class, follow these steps:

1. **Check if modification is necessary**: Review whether your change should be in the codegen system itself (preferred) or in a manual override.
2. **For minor extensions** (properties, helper methods): Create a manual subclass.
3. **For systemic changes** (affecting all keywords): Update the codegen templates.

## Creating a Manual Subclass

1. Create a file under `keyword_classes/manual/` with the same name as the auto-generated class.
2. Import and subclass the auto-generated class:
   ```python
   from ansys.dyna.core.keywords.keyword_classes.auto.define_table import DefineTable as _AutoDefineTable

   class DefineTable(_AutoDefineTable):
       # Add custom properties, methods, etc.
   ```
3. Export it from `manual_keywords.py`:
   ```python
   from .manual.define_table import DefineTable  # noqa: F401
   ```
4. The manual class will override the auto-generated class when `keyword_classes` is imported.

## Why This Approach?

- **Preserves codegen**: Regenerating auto classes won't overwrite your customizations.
- **PR-friendly**: Codegen checks verify that auto files match the templates; manual subclasses don't interfere.
- **Maintainable**: Changes are isolated and clear.
