# Code Generation and Auto-Generated Keywords

Many keyword classes in `src/ansys/dyna/core/keywords/keyword_classes/auto/` are auto-generated by Jinja templates. Avoid modifying these files directly.

## Purpose

The purpose of the codegen system is to generate Python classes for LS-DYNA keywords. These keywords are described in details in the LS-DYNA manual.

## Codegen System: High-Level Design

The codegen system is responsible for generating Python classes and import machinery for LS-DYNA keywords. Its architecture consists of:

- **Specification Loading**: Reads keyword/card/field definitions from JSON manifest files (`kwd.json`, `manifest.json`, `additional-cards.json`).
- **Handler Pipeline**: Applies a series of handlers to process and transform the loaded specifications. Each handler encapsulates a specific transformation or enrichment step.
- **Template Rendering**: Uses Jinja templates to generate Python code for keyword classes, importers, and type mappings. Context for templates is built from processed specifications.
- **Output Management**: Writes generated files to the appropriate locations, typically under `src/ansys/dyna/core/keywords/keyword_classes/auto/`.

Note: kwd.json is extremely large, so the agent should never attempt to read it in its entirety

### Typical Flow

1. **Run `generate.py`**: Entry point for code generation. CLI options allow for cleaning (`-C`) and generation.
2. **Load Specs**: Manifest and keyword definitions are loaded and validated.
3. **Apply Handlers**: Each handler processes the data, adding relationships, defaults, or other logic.
4. **Render Templates**: Jinja templates are rendered using the processed context.
5. **Write Output**: Generated files are written to disk.

### Refactoring

Due to the complexity of the codegen, for any non-trivial refactoring, verify the codegen between independent
steps. Otherwise, after making many changes, it can be difficult to isolate and fix issues caused by
early steps.

### Extending or Customizing

- For changes affecting all keywords, update the codegen templates or handler logic.
- For keyword-specific customizations, create manual subclasses as described below.
- To test the generation of a specific keyword, use codegen.py -k SECTION_SHELL (for example).

See `codegen/todo.md` for architectural improvement recommendations.

## Handler System Architecture

### Handler Execution Order

Handlers transform keyword metadata during code generation. **Order matters** because handlers often depend on the output of previous handlers.

**Critical Ordering Principle**: Handlers are registered and executed in a specific order defined in `registry.py`. While the refactored system supports declaring dependencies via the `@handler` decorator, the current implementation uses **explicit registration order** to maintain backward compatibility and ensure reference semantics work correctly.

**Why Not Topological Sort?** The handler system includes infrastructure for dependency-based ordering (topological sort), but uses explicit registration order because handlers that group cards (`card-set`, `table-card-group`) rely on **reference semantics** - they append references to card dictionaries, not copies. Later handlers modify these same objects in-place. A pure dependency-based approach could reorder handlers in ways that break this pattern.

**Note**: Typed dataclasses (`KeywordData`, `Card`, `Field`) are available in `data_model/keyword_data.py` for improved type safety, with backward-compatible `to_dict()`/`from_dict()` methods for gradual migration.

### Handler Pipeline: Dict vs. DataClass Access

As of Step 3 (December 2025), the handler pipeline has been migrated to use **KeywordData dataclass instances** with attribute access:

**Handler Implementation**:
- Handlers receive `KeywordData` instances and use attribute access: `kwd_data.cards`, `kwd_data.options`
- All 15 handlers have been updated from `kwd_data["field"]` to `kwd_data.field`

**Why Cards Stay as Dicts**:
- `KeywordData.cards` is typed as `List[Dict[str, Any]]` (not `List[Card]`)
- Handlers add metadata keys dynamically: `card["duplicate"] = {...}`, `card["variable"] = {...}`
- These keys aren't part of the `Card` dataclass schema, requiring dict mutation

**Conversion Boundaries**:
- `_before_handle`: Operates on dict (legacy code)
- Handlers: Receive and modify KeywordData instances
- `_after_handle`: Receives dict for mutations, KeywordData for `post_process_all()`

**Hybrid Access Patterns**:
- During transition, some fields (e.g., `options`) may be `OptionGroup` instances or dicts
- Use `hasattr(option, 'cards')` check: `cards = option.cards if hasattr(option, 'cards') else option["cards"]`

This hybrid approach enables gradual migration to typed structures while maintaining backward compatibility.

### Type Hints and Metadata Classes

The codegen system uses typed metadata classes to replace `Dict[str, Any]` patterns:

**Metadata Classes** (`data_model/metadata.py`):
- `DuplicateCardMetadata` - for card["duplicate"] (table cards)
- `VariableCardMetadata` - for card["variable"] (series cards)
- `ExternalCardMetadata` - for card["external"] (external implementations)
- `OptionGroup` - for kwd_data["options"] items
- `CardSet`, `CardSetsContainer` - for kwd_data["card_sets"]
- `LinkData` - for kwd_data["links"] items
- `MixinImport` - for kwd_data["mixin_imports"] items
- `DataclassDefinition`, `DataclassField` - for kwd_data["dataclasses"] items

All metadata classes include `to_dict()`/`from_dict()` methods for backward compatibility.

**Handler Settings** (`data_model/handler_settings.py`):
- Each handler has a typed settings dataclass (e.g., `TableCardSettings`, `SeriesCardSettings`)
- Use these for type-safe configuration instead of raw dicts
- Convert from manifest.json dicts using `from_dict()` class methods

**Migration Pattern**:
- `Card` and `KeywordData` use `Union[TypedClass, Dict[str, Any]]` for gradual migration
- Handlers currently accept `Dict[str, Any]` but can be updated to use typed classes
- See `handlers/skip_card.py` for example of typed handler signature

**Standard Handler Order** (as of Dec 2025):
1. `reorder-card` - Reorders cards; must run first since other handlers use positional indices
2. `table-card` - Transforms cards into repeatable tables
3. `override-field` - Modifies field properties
4. `replace-card` - Replaces entire cards with different definitions
5. `insert-card` - Inserts new cards at specified positions
6. `series-card` - Transforms cards into variable-length series
7. `add-option` - Adds keyword options
8. `card-set` - Groups cards into reusable sets (uses references, not copies!)
9. `conditional-card` - Adds conditional logic to cards (modifies cards in-place)
10. `rename-property` - Renames property accessors
11. `skip-card` - Marks cards to be skipped
12. `table-card-group` - Groups multiple cards into repeating units
13. `external-card-implementation` - Links to externally defined cards
14. `shared-field` - Creates shared field definitions
15. `override-subkeyword` - Overrides subkeyword behavior

### Reference Semantics vs. Deep Copies

**CRITICAL**: Most handlers that group or copy cards (e.g., `card-set`, `table-card-group`) use **reference semantics** - they append the actual card dictionaries to their collections, NOT deep copies.

**Why?** Later handlers modify cards in-place. For example:
- `card-set` (handler #8) creates a card set by appending references to `source_cards`
- `conditional-card` (handler #9) later sets the `func` property on those same card objects
- Because they're the same objects, the changes appear in both places

**If you use `copy.deepcopy()`**: Changes made by later handlers won't appear in the card-set, breaking generation.

### Index Handling After Reordering

**The Index System**:
- Each card has an `index` property indicating its position
- `reorder-card` reorders the `kwd_data["cards"]` list but does NOT update card indices
- Subsequent handlers use list positions (e.g., `kwd_data["cards"][3]`) not the card's `index` property
- When `card-set` copies cards, it stores the original index in `source_index` and assigns new sequential indices

**Example** (SECTION_SHELL):
```json
// Original cards: [card0, card1, card2, card3, card4, card5]
// Reorder: [0, 1, 4, 2, 3, 5]
// After reorder: [card0, card1, card4, card2, card3, card5]
//                 pos0   pos1   pos2   pos3   pos4   pos5

// conditional-card with index:3 operates on position 3 (which is original card2)
// card-set with source-indices:[0,1,2,3,4,5] copies from positions 0-5
```

## When Auto-Generated Files Change

If you need to extend or customize a keyword class, follow these steps:

1. **Check if modification is necessary**: Review whether your change should be in the codegen system itself (preferred) or in a manual override.
2. **For minor extensions** (properties, helper methods): Create a manual subclass.
3. **For systemic changes** (affecting all keywords): Update the codegen templates.

## Creating a Manual Subclass

1. Create a file under `keyword_classes/manual/` with the same name as the auto-generated class.
2. Import and subclass the auto-generated class:
   ```python
   from ansys.dyna.core.keywords.keyword_classes.auto.define_table import DefineTable as _AutoDefineTable

   class DefineTable(_AutoDefineTable):
       # Add custom properties, methods, etc.
   ```
3. Export it from `manual_keywords.py`:
   ```python
   from .manual.define_table import DefineTable  # noqa: F401
   ```
4. The manual class will override the auto-generated class when `keyword_classes` is imported.

## Why This Approach?

- **Preserves codegen**: Regenerating auto classes won't overwrite your customizations.
- **PR-friendly**: Codegen checks verify that auto files match the templates; manual subclasses don't interfere.
- **Maintainable**: Changes are isolated and clear.
